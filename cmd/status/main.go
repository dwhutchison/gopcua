// Copyright 2018 gopcua authors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

// This script automatically generates the status/status.go file for implementing
// all the OPC-UA Status Codes as defined in Part 6 A.2:
// http://www.opcfoundation.org/UA/schemas/1.04/StatusCode.csv

package main

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"regexp"
)

func main() {
	infile := "StatusCode.csv"
	outfile := "../../status/status.go"

	switch numArgs := len(os.Args); numArgs {
	case 3:
		outfile = os.Args[2]
		fallthrough
	case 2:
		infile = os.Args[1]
	}

	// read csv file
	file, err := ioutil.ReadFile(infile)
	if err != nil {
		panic(err)
	}

	// create temporary buffer
	var b bytes.Buffer

	b.WriteString(`// Code generated by cmd/status; DO NOT EDIT

	package status
	
	import "fmt"
	
	// StatusCode describes the UA Status Codes as defined in Part 6 A.2
	type StatusCode struct {
		code        uint32
		description string
	}

	// New instantiates a new StatusCode object
	func New(code uint32, description string) (*StatusCode) {
		return &StatusCode{
			code: code,
			description: description, 
		}
	}	

	// Error implements the error interface on StatusCode
	func (s *StatusCode) Error() string {
		return s.String()
	}
	
	// String implements the stringer interface on StatusCode
	func (s *StatusCode) String() string {
		return fmt.Sprintf("0x%X: %s", s.code, s.description)
	}

	// Code returns the error code from a StatusCode object
	func (s *StatusCode) Code() uint32 {
		return s.code
	}

	// Description returns the error code from a StatusCode object
	func (s *StatusCode) Description() string {
		return s.description
	}
	
	// StatusCode definitions from http://www.opcfoundation.org/UA/schemas/1.04/StatusCode.csv
	var (
`)

	// Replace the first two commas in the file with semicolons to help the csv parser grab
	// the entire third column (description) when it contains a comma
	re := regexp.MustCompile(`([[:print:]]+?),([[:print:]]+?),\s*(.*)`)
	file = re.ReplaceAll(file, []byte("${1};${2};${3}"))

	// loop over each row
	reader := csv.NewReader(bytes.NewBuffer(file))
	reader.Comma = ';'

	for {
		record, err := reader.Read()
		if err != nil {
			if err == io.EOF {
				break
			}
			panic(err)
		}
		b.WriteString(fmt.Sprintf("%s = StatusCode{code: %s, description: %q}\n", record[0], record[1], record[2]))
	}

	// close var(...) bracket
	b.Write([]byte(")"))

	// format file
	fmt, err := format.Source(b.Bytes())
	if err != nil {
		panic(err)
	}

	// write formatted code to file
	out, err := os.Create(outfile)
	if err != nil {
		panic(err)
	}
	defer out.Close()
	out.Write(fmt)

	log.Println("done")
}
